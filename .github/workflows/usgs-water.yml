name: USGS Water Cache (daily)

on:
  schedule:
    - cron: "35 13 * * *"   # daily 13:35 UTC
  workflow_dispatch:

concurrency:
  group: cache-water
  cancel-in-progress: false

permissions:
  contents: write

jobs:
  cache-water:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Fetch USGS temp/cond/pH/TDS/DO/Turbidity for all states & territories
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p data

          node - <<'NODE'
          const fs = require('fs');

          // ------------------------------
          // Config
          // ------------------------------
          const STATES = [
            'al','ak','az','ar','ca','co','ct','de','fl','ga','hi','id','il','in','ia','ks','ky','la','me','md','ma','mi','mn','ms','mo','mt','ne','nv','nh','nj','nm','ny','nc','nd','oh','ok','or','pa','ri','sc','sd','tn','tx','ut','vt','va','wa','wv','wi','wy',
            'dc','pr','vi','gu','as','mp'
          ];
          const BASE   = 'https://waterservices.usgs.gov/nwis/iv/?format=json&siteType=ST&siteStatus=active';
          // 00010 tempC, 00095 specific conductance, 00400 pH, 70300 TDS (mg/L), 00300 DO (mg/L), 00076 Turb NTU, 63680 Turb FNU
          const PARAMS = '00010,00095,00400,70300,00300,00076,63680';
          const sleep  = (ms)=>new Promise(r=>setTimeout(r,ms));

          // Treat bad sentinels as missing
          const CLEAN = (v) => {
            const n = Number(v);
            return Number.isFinite(n) && n > -1000 ? n : null;
          };

          const latestValue = (series) => {
            const arr = series?.values?.[0]?.value;
            if (!arr || !arr.length) return null;
            return Number(arr[arr.length - 1]?.value);
          };

          async function fetchState(st) {
            const url = `${BASE}&parameterCd=${PARAMS}&stateCd=${st}`;
            for (let attempt = 1; attempt <= 3; attempt++) {
              try {
                const res = await fetch(url);
                if (!res.ok) {
                  console.warn(`WARN ${st.toUpperCase()}: HTTP ${res.status}`);
                  if (attempt < 3) { await sleep(500 * attempt); continue; }
                  return { state: st, items: [] };
                }
                const json = await res.json();
                const ts = json?.value?.timeSeries || [];

                const bySite = new Map();
                for (const s of ts) {
                  const site = s?.sourceInfo?.siteCode?.[0]?.value;
                  if (!site) continue;

                  const code = s?.variable?.variableCode?.[0]?.value; // '00010','00095','00400','70300','00300','00076','63680'
                  const rec = bySite.get(site) || {
                    site, state: st,
                    tempC: null, condu: null, ph: null, tds: null,
                    do_mgL: null, turb_NTU: null, turb_FNU: null,
                    tdsEst: null
                  };

                  const v = latestValue(s);
                  if (code === '00010') rec.tempC    = CLEAN(v);
                  if (code === '00095') rec.condu    = CLEAN(v);
                  if (code === '00400') rec.ph       = CLEAN(v);
                  if (code === '70300') rec.tds      = CLEAN(v);
                  if (code === '00300') rec.do_mgL   = CLEAN(v);
                  if (code === '00076') rec.turb_NTU = CLEAN(v);
                  if (code === '63680') rec.turb_FNU = CLEAN(v);

                  bySite.set(site, rec);
                }

                // TDS estimate if measured TDS absent but conductance present
                for (const rec of bySite.values()) {
                  if ((rec.tds == null) && (rec.condu != null)) {
                    rec.tdsEst = Math.round(rec.condu * 0.67);
                  }
                }

                return { state: st, items: Array.from(bySite.values()) };
              } catch (e) {
                console.warn(`WARN ${st.toUpperCase()}: ${e.message}`);
                if (attempt < 3) { await sleep(500 * attempt); continue; }
                return { state: st, items: [] };
              }
            }
          }

          const median = (arr) => {
            const xs = arr.filter(v => v !== null);
            if (xs.length < 3) return null;           // require ≥3 values
            xs.sort((a,b)=>a-b);
            const m = Math.floor(xs.length/2);
            const val = xs.length % 2 ? xs[m] : (xs[m-1] + xs[m]) / 2;
            return Number(val);
          };

          const rounders = {
            tempC:  (x)=> Number(x.toFixed(1)),
            condu:  (x)=> Math.round(x),
            ph:     (x)=> Number(x.toFixed(2)),
            tds:    (x)=> Math.round(x),
            do_mgL: (x)=> Number(x.toFixed(1)),
            turb:   (x)=> Number(x.toFixed(1)),
          };

          (async () => {
            const all = [];
            for (const st of STATES) {
              const r = await fetchState(st);
              all.push(...r.items);
              await sleep(700); // gentle pacing
            }

            const stamp = new Date().toISOString();
            const out = { updatedAt: stamp, count: all.length, items: all };

            // Guard vs previous run: require >= 75% of prior count
            try {
              const prev = JSON.parse(fs.readFileSync('data/usgs-latest.json','utf8'));
              const prevCount = prev?.count;
              if (prevCount && out.count < Math.floor(prevCount * 0.75)) {
                throw new Error(`Guard: new count ${out.count} < 75% of previous ${prevCount}`);
              }
            } catch {}

            // Aggregate by 2-letter state
            const groups = new Map();
            for (const it of all) {
              const key = it.state.toUpperCase();
              const g = groups.get(key) || {
                count: 0, temps: [], conds: [], phs: [], tdses: [], dos: [], turbsNTU: [], turbsFNU: []
              };
              g.count++;
              if (Number.isFinite(it.tempC))     g.temps.push(it.tempC);
              if (Number.isFinite(it.condu))     g.conds.push(it.condu);
              if (Number.isFinite(it.ph))        g.phs.push(it.ph);
              if (Number.isFinite(it.do_mgL))    g.dos.push(it.do_mgL);
              if (Number.isFinite(it.turb_NTU))  g.turbsNTU.push(it.turb_NTU);
              if (Number.isFinite(it.turb_FNU))  g.turbsFNU.push(it.turb_FNU);

              const tdsInput = Number.isFinite(it.tds) ? it.tds
                                : (Number.isFinite(it.tdsEst) ? it.tdsEst : null);
              if (tdsInput != null) g.tdses.push(tdsInput);
              groups.set(key, g);
            }

            const stateRows = [];
            for (const [st, g] of [...groups.entries()].sort((a,b)=>a[0].localeCompare(b[0]))) {
              const medTemp = median(g.temps);
              const medCond = median(g.conds);
              const medPH   = median(g.phs);
              const medTDS  = median(g.tdses);
              const medDO   = median(g.dos);
              const medNTU  = median(g.turbsNTU);
              const medFNU  = median(g.turbsFNU);

              stateRows.push({
                state: st,
                sites: g.count,
                medianTempC:      medTemp == null ? null : rounders.tempC(medTemp),
                medianCond_uScm:  medCond == null ? null : rounders.condu(medCond),
                medianPH:         medPH   == null ? null : rounders.ph(medPH),
                medianTDS_mgL:    medTDS  == null ? null : rounders.tds(medTDS),
                medianDO_mgL:     medDO   == null ? null : rounders.do_mgL(medDO),
                medianTurb_NTU:   medNTU  == null ? null : rounders.turb(medNTU),
                medianTurb_FNU:   medFNU  == null ? null : rounders.turb(medFNU)
              });
            }

            // Write files
            fs.writeFileSync('data/usgs-latest.json', JSON.stringify(out,  null, 2));
            fs.writeFileSync('data/state-summary.json', JSON.stringify({ updatedAt: stamp, states: stateRows }, null, 2));
            fs.writeFileSync('data/health.json',       JSON.stringify({ updatedAt: stamp }, null, 2));

            // Step summary table (short)
            const dash = [];
            const fmt = (x)=> (x === null ? '—' : String(x));
            dash.push(`# USGS Cache Summary\n`);
            dash.push(`Updated: ${stamp}`);
            dash.push(`Total sites: ${out.count}\n`);
            dash.push(`| State | Sites | °C | µS/cm | pH | TDS mg/L | DO mg/L | Turb (NTU) |`);
            dash.push(`|:-----:|-----:|---:|------:|--:|---------:|--------:|-----------:|`);
            for (const r of stateRows) {
              dash.push(`| ${r.state} | ${r.sites} | ${fmt(r.medianTempC)} | ${fmt(r.medianCond_uScm)} | ${fmt(r.medianPH)} | ${fmt(r.medianTDS_mgL)} | ${fmt(r.medianDO_mgL)} | ${fmt(r.medianTurb_NTU ?? r.medianTurb_FNU)} |`);
            }
            if (process.env.GITHUB_STEP_SUMMARY) {
              fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, dash.join('\n') + '\n');
            }
            console.log(`Wrote ${out.count} sites at ${stamp}`);
          })().catch(e => { console.error(e); process.exit(1); });
          NODE

      - name: Show summary
        run: cat "$GITHUB_STEP_SUMMARY" || true

      - name: Commit & push
        run: |
          git config user.name "admatera-bot"
          git config user.email "actions@users.noreply.github.com"
          git add data/usgs-latest.json data/state-summary.json data/health.json
          git commit -m "water cache $(date -u +'%F %T UTC')" || echo "no changes"
          git push
