name: USGS Water Cache (daily)

on:
  schedule:
    - cron: "35 13 * * *"   # daily 13:35 UTC
  workflow_dispatch:

permissions:
  contents: write

jobs:
  cache-water:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Fetch USGS temp/cond + pH/TDS for all states & territories
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p data

          node - <<'NODE'
          const fs = require('fs');

          // ------------------------------
          // Config
          // ------------------------------
          const STATES = [
            'al','ak','az','ar','ca','co','ct','de','fl','ga','hi','id','il','in','ia','ks','ky','la','me','md','ma','mi','mn','ms','mo','mt','ne','nv','nh','nj','nm','ny','nc','nd','oh','ok','or','pa','ri','sc','sd','tn','tx','ut','vt','va','wa','wv','wi','wy',
            'dc','pr','vi','gu','as','mp'
          ];
          const BASE   = 'https://waterservices.usgs.gov/nwis/iv/?format=json&siteType=ST&siteStatus=active';
          // 00010=temp C, 00095=spec. conductance (µS/cm), 00400=pH, 70300=TDS mg/L
          const PARAMS = '00010,00095,00400,70300';
          const sleep  = (ms)=>new Promise(r=>setTimeout(r,ms));

          // Treat big negative sentinels as missing
          const CLEAN = (v) => {
            const n = Number(v);
            return Number.isFinite(n) && n > -1000 ? n : null;
          };

          const latestValue = (series) => {
            const arr = series?.values?.[0]?.value;
            if (!arr || !arr.length) return null;
            return Number(arr[arr.length - 1]?.value);
          };

          async function fetchState(st) {
            const url = `${BASE}&parameterCd=${PARAMS}&stateCd=${st}`;
            for (let attempt = 1; attempt <= 3; attempt++) {
              try {
                const res = await fetch(url);
                if (!res.ok) {
                  console.warn(`WARN ${st.toUpperCase()}: HTTP ${res.status}`);
                  if (attempt < 3) { await sleep(500 * attempt); continue; }
                  return { state: st, items: [] };
                }
                const json = await res.json();
                const ts = json?.value?.timeSeries || [];

                const bySite = new Map();
                for (const s of ts) {
                  const site = s?.sourceInfo?.siteCode?.[0]?.value;
                  if (!site) continue;

                  const code = s?.variable?.variableCode?.[0]?.value; // '00010','00095','00400','70300'
                  const rec = bySite.get(site) || { site, state: st, tempC: null, condu: null, ph: null, tds: null, tdsEst: null };

                  const v = CLEAN(latestValue(s));
                  if (code === '00010') rec.tempC = v;            // °C
                  if (code === '00095') rec.condu = v;            // µS/cm
                  if (code === '00400') rec.ph    = v;            // pH (std units)
                  if (code === '70300') rec.tds   = v;            // mg/L

                  bySite.set(site, rec);
                }

                // derive TDS estimate if measured TDS missing but conductivity present
                for (const r of bySite.values()) {
                  if ((r.tds == null) && Number.isFinite(r.condu)) {
                    // empirical rule: TDS (mg/L) ≈ 0.67 × µS/cm
                    r.tdsEst = Math.round(r.condu * 0.67);
                  }
                }

                return { state: st, items: Array.from(bySite.values()) };
              } catch (e) {
                console.warn(`WARN ${st.toUpperCase()}: ${e.message}`);
                if (attempt < 3) { await sleep(500 * attempt); continue; }
                return { state: st, items: [] };
              }
            }
          }

          const median = (arr, decimals=1) => {
            const xs = arr.filter(v => v !== null && Number.isFinite(v));
            if (!xs.length) return null;
            xs.sort((a,b)=>a-b);
            const m = Math.floor(xs.length/2);
            const val = xs.length % 2 ? xs[m] : (xs[m-1] + xs[m]) / 2;
            return +Number(val).toFixed(decimals);
          };

          (async () => {
            const all = [];
            for (const st of STATES) {
              const r = await fetchState(st);
              all.push(...r.items);
              await sleep(700); // gentle pacing
            }

            const stamp = new Date().toISOString();
            const out = { updatedAt: stamp, count: all.length, items: all };

            // Guard vs previous run: require >= 75% of prior count
            try {
              const prev = JSON.parse(fs.readFileSync('data/usgs-latest.json','utf8'));
              const prevCount = prev?.count;
              if (prevCount && out.count < Math.floor(prevCount * 0.75)) {
                throw new Error(`Guard: new count ${out.count} < 75% of previous ${prevCount}`);
              }
            } catch {}

            // State medians
            const groups = new Map();
            for (const it of all) {
              const key = it.state.toUpperCase();
              const g = groups.get(key) || { count: 0, temps: [], conds: [], phs: [], tdsMeas: [], tdsEst: [] };
              g.count++;
              if (it.tempC  != null) g.temps.push(it.tempC);
              if (it.condu  != null) g.conds.push(it.condu);
              if (it.ph     != null) g.phs.push(it.ph);
              if (it.tds    != null) g.tdsMeas.push(it.tds);
              if (it.tdsEst != null) g.tdsEst.push(it.tdsEst);
              groups.set(key, g);
            }

            const stateRows = [];
            for (const [st, g] of [...groups.entries()].sort((a,b)=>a[0].localeCompare(b[0]))) {
              const medTemp = median(g.temps, 1);
              const medCond = median(g.conds, 0); // round to integer µS/cm
              const medPH   = median(g.phs,   1); // pH to 0.1
              const medTDSm = median(g.tdsMeas, 0);
              const medTDSe = median(g.tdsEst, 0);
              const medTDS  = (medTDSm !== null) ? medTDSm : (medTDSe !== null ? medTDSe : null);

              stateRows.push({
                state: st,
                sites: g.count,
                medianTempC: medTemp,
                medianCond_uScm: medCond,
                medianPH: medPH,
                medianTDS_mgL: medTDS
              });
            }

            // Write files
            fs.writeFileSync('data/usgs-latest.json', JSON.stringify(out,  null, 2));
            fs.writeFileSync('data/state-summary.json', JSON.stringify({ updatedAt: stamp, states: stateRows }, null, 2));
            fs.writeFileSync('data/health.json',       JSON.stringify({ updatedAt: stamp }, null, 2));

            // Step summary (adds pH/TDS columns)
            const dash = [];
            dash.push(`# USGS Cache Summary\n`);
            dash.push(`Updated: ${stamp}`);
            dash.push(`Total sites: ${out.count}\n`);
            dash.push(`| State | Sites | Median °C | Median µS/cm | Median pH | Median TDS mg/L |`);
            dash.push(`|:-----:|-----:|----------:|-------------:|----------:|----------------:|`);
            const F = (x)=> (x === null ? '—' : String(x));
            for (const r of stateRows) {
              dash.push(`| ${r.state} | ${r.sites} | ${F(r.medianTempC)} | ${F(r.medianCond_uScm)} | ${F(r.medianPH)} | ${F(r.medianTDS_mgL)} |`);
            }
            if (process.env.GITHUB_STEP_SUMMARY) {
              fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, dash.join('\n') + '\n');
            }
            console.log(`Wrote ${out.count} sites at ${stamp}`);
          })().catch(e => { console.error(e); process.exit(1); });
          NODE

      - name: Show summary
        run: cat "$GITHUB_STEP_SUMMARY" || true

      - name: Commit & push
        run: |
          git config user.name "admatera-bot"
          git config user.email "actions@users.noreply.github.com"
          git add data/usgs-latest.json data/state-summary.json data/health.json
          git commit -m "water cache $(date -u +'%F %T UTC')" || echo "no changes"
          git push
